# 다이나믹 프로그래밍
# 메모리 공간이 많이 필요하거나, 연산 속도의 한계등이 있기때문에 최대한으로 활용할 수 있도록 알고리즘을 작성해야함
# 메모리 공간을 약간 더 사용시 비약적으로 연산속도를 증가시킬 수 있는게 동적 프로그래밍
# 2가지 방법 (top-down) (bottom-up)
# 대표적 예시가 피보나치 수열(이전 두 항의 합을 현재 항으로 설정하는 방식 수열) -> 1 1 2 3 5 8 13 21 34 55
# 피보나치 수열의 첫번째는 1 두번쨰도 1 이후 n번째 피보나치 수 = n-1번째 피보나치 수 + n-2번째 피보나치수
# 배열 또는 리스트로 표현 가능하고

# 피보나치 수열 함수 구현
num = int(input())
d = [0] * (num + 1)  # 구하고자 하는 수열까지의 값을 담을 빈 배열

# top-down 방식은 재귀를 사용하여 큰 문제를 위해 같은 구조의 작은 문제를 호출
# def fibonacci(n):
#     # 호출되는 함수 확인
#     print(f"f({n})", end=" ")
#     if n == 1 or n == 2:
#         return 1
#     if d[n] != 0:  # 값이 0 즉 처음 재귀 호출된 것이 아니면 기존에 있는 것을 사용하도록 return
#         return d[n]
#     d[n] = fibonacci(n - 1) + fibonacci(n - 2)  # 재귀로 호출 (0으로 초기화된 배열에 값을 할당 -> 이제 다음에 방문시 0이 아님)
#     return d[n]
#
#
# fibonacci(num)
# print(fibonacci(num)) # return 값 확인
# n이 커질수록 수행시간이 기하급수적으로 늘어남 O(2N) 이기에 30이면 약 10억 연산횟수
# 이때 메모이제이션 기법을 사용하여 한번 구한 결과는 메모리 공간에 넣어두고 같은 식을 사용시 그대로 값을 가져오는 일종의 캐싱 기능 (top-down에 국한되어 사용ㅈㅂ)
# 단 큰 문제를 작은 문제로 나눌 수 있어야하며, 작은문제에 구한 답이 큰 문제에도 동일시 되어야 적용 가능


# bottom-up 방식은 작은 문제부터 반복문을 사용하여 반복적으로 답을 도출하는 방식
d[1] = 1
d[2] = 1
for i in range(3, num + 1):
    d[i] = d[i - 2] + d[i - 1]

print(d[num])
